# ОТЧЕТ

по практическому занятию №1  
**«Каркас игрового движка и базовая интеграция рендера»**

## 1. Титульный лист (данные для оформления)

- ФИО студента: **Иманаков Владислав Павлович**
- Группа: **J3300**
- Название работы: **Практическое занятие №1. Каркас игрового движка и базовая интеграция рендера**

Примечание: титульный лист обычно оформляется по шаблону кафедры/вуза. Если есть официальный шаблон, перенести данные из этого раздела в шаблон.

## 2. Цель работы

Создать минимальный рабочий каркас игрового движка с поддержкой игрового цикла и визуализации графического вывода через адаптер рендеринга.

## 3. Постановка задачи (по заданию из PDF)

Требовалось реализовать:

1. Класс `Application`, управляющий жизненным циклом приложения.
2. Систему состояний игры (например, загрузка, меню, игровой режим).
3. Расчет `deltaTime` для корректного обновления логики между кадрами.
4. Систему логирования событий и ошибок.
5. Адаптер рендеринга (`RenderAdapter`) для отделения основной логики от графической библиотеки.
6. Отрисовку тестового примитива в графическом окне.

Дополнительное задание:

1. Обработка клавиатуры (стрелки) для перемещения объекта.
2. Обработка мыши:
   - ЛКМ — масштабирование объекта,
   - ПКМ — вращение объекта.
3. Плавное изменение параметров с учетом `deltaTime`.

## 4. Используемые средства

- Язык программирования: **C++17**
- Система сборки: **CMake**
- Графическая библиотека: **raylib** (через `FetchContent`)
- Среда разработки: **Visual Studio 2022**
- Контроль версий: **Git**
- Репозиторий проекта: **https://github.com/Vladislavim/Engine_AID**

## 5. Общая архитектура решения

Проект реализован как минимальный каркас игрового приложения с разделением ответственности между модулями.

### 5.1. Центральный класс `Application`

Класс `Application` управляет жизненным циклом программы:

- инициализация логирования и рендера;
- запуск главного цикла;
- вычисление `deltaTime` с помощью `std::chrono::steady_clock`;
- обработка переходов между состояниями;
- завершение работы и освобождение ресурсов.

Основной цикл организован по схеме:

1. вычисление `deltaTime`;
2. чтение ввода;
3. обновление текущего состояния;
4. отрисовка кадра.

### 5.2. Система состояний игры

Реализована базовая система состояний с общим интерфейсом:

- `LoadingState`
- `MenuState`
- `GameplayState`

Каждое состояние имеет методы входа, выхода, обновления и отрисовки. Это позволяет изолировать логику разных режимов работы приложения и упростить расширение проекта.

### 5.3. Адаптер рендеринга (`RenderAdapter`)

Рендеринг вынесен за интерфейс `IRenderAdapter`, который скрывает детали конкретной библиотеки.

В проекте реализован `RaylibRenderAdapter`, который обеспечивает:

- создание окна;
- обработку ввода;
- начало/завершение кадра;
- отрисовку примитива;
- вывод текста;
- корректное завершение работы окна.

Такой подход позволяет заменить графическую библиотеку без изменения основного каркаса приложения.

### 5.4. Система логирования

Реализован модуль `Logger`, который пишет сообщения:

- в консоль;
- в файл `logs/app.log`.

Логируются:

- запуск и завершение приложения;
- переходы между состояниями;
- значения `deltaTime`.

### 5.5. Обработка ввода

Обработка управления вынесена в класс `InputController`.

Реализовано:

- перемещение примитива стрелками;
- масштабирование по ЛКМ;
- вращение по ПКМ;
- плавное изменение параметров с учетом `deltaTime`.

## 6. Структура проекта

Основные файлы проекта:

- `CMakeLists.txt` — конфигурация сборки
- `src/main.cpp` — точка входа
- `src/core/Application.h`, `src/core/Application.cpp` — каркас приложения и главный цикл
- `src/core/Logger.h`, `src/core/Logger.cpp` — логирование
- `src/core/GameState.h` — базовый интерфейс состояния
- `src/core/States.h`, `src/core/States.cpp` — состояния `Loading`, `Menu`, `Gameplay`
- `src/render/IRenderAdapter.h` — интерфейс адаптера рендера
- `src/render/RaylibRenderAdapter.h`, `src/render/RaylibRenderAdapter.cpp` — реализация адаптера на `raylib`
- `src/game/InputController.h`, `src/game/InputController.cpp` — управление объектом и ввод

## 7. Реализованная функциональность (результат работы)

В результате выполнения задания получено приложение, которое:

1. Запускает графическое окно.
2. Работает в рамках главного игрового цикла.
3. Вычисляет `deltaTime` и выводит его в лог.
4. Поддерживает переключение состояний (`Loading`, `Menu`, `Gameplay`).
5. Отрисовывает тестовый примитив (квадрат).
6. Позволяет управлять примитивом с клавиатуры и мыши.
7. Выполняет плавные изменения положения/масштаба/поворота с учетом `deltaTime`.

## 8. Листинги наиболее значимых частей кода

В отчет рекомендуется вставить фрагменты следующих файлов:

1. Интерфейс адаптера рендера: `src/render/IRenderAdapter.h`
2. Главный цикл и расчет `deltaTime`: `src/core/Application.cpp`
3. Базовый интерфейс состояния и реализация состояний: `src/core/GameState.h`, `src/core/States.cpp`
4. Обработка ввода с учетом `deltaTime`: `src/game/InputController.cpp`
5. Реализация рендера через `raylib`: `src/render/RaylibRenderAdapter.cpp`

## 9. Скриншоты рабочего приложения

В соответствии с требованиями к отчету необходимо приложить скриншоты.

Рекомендуемый набор:

1. Окно приложения в состоянии `Menu`
2. Окно приложения в состоянии `Gameplay` с тестовым примитивом
3. Демонстрация изменения положения/масштаба/поворота
4. Консоль/лог с выводом `deltaTime` и переходов между состояниями

Место для вставки изображений (после сохранения в `docs/screenshots/`):

- `docs/screenshots/menu.png`
- `docs/screenshots/gameplay.png`
- `docs/screenshots/controls_demo.png`
- `docs/screenshots/logs.png`

Пример вставки в итоговый PDF/Word:

- Скриншот 1. Состояние меню.
- Скриншот 2. Состояние игрового режима с примитивом.
- Скриншот 3. Результат работы обработки ввода.
- Скриншот 4. Логирование значений `deltaTime`.

## 10. Тестирование и проверка работоспособности

Проверена следующая функциональность:

1. Запуск приложения и создание окна рендера.
2. Переключение между состояниями (`1`, `2`, `3`, `Enter`, `Esc`).
3. Отрисовка тестового примитива в `Gameplay`.
4. Перемещение объекта стрелками.
5. Масштабирование по ЛКМ.
6. Вращение по ПКМ.
7. Вывод значений `deltaTime` в журнал.

Результат: функциональность работает корректно, поведение объекта визуально плавное.

## 11. Выводы и комментарии по трудностям

В ходе выполнения работы был реализован минимальный каркас игрового движка с возможностью дальнейшего расширения.

Основные результаты:

- реализован класс `Application` и главный цикл;
- добавлен расчет `deltaTime` и журналирование;
- реализована система состояний;
- реализован `RenderAdapter` и конкретный адаптер для `raylib`;
- выполнена отрисовка тестового примитива;
- реализовано дополнительное задание по обработке ввода клавиатуры и мыши.

Трудности:

- при сборке через новую версию CMake возникла несовместимость с `raylib` (предупреждение/ошибка по старой минимальной версии CMake в зависимом проекте);
- проблема была устранена настройкой политики CMake в основном `CMakeLists.txt`.

## 12. Приложения к отчету

### 12.1. Исходный код

Репозиторий проекта:

**https://github.com/Vladislavim/Engine_AID**

### 12.2. Конфигурационные файлы

В репозитории присутствуют:

- `CMakeLists.txt`
- `.gitignore`
- документация в папке `docs/`

### 12.3. Дополнительные материалы

При необходимости можно приложить:

- видео демонстрации работы приложения;
- архив со скриншотами;
- экспортированный PDF-отчет.

## 13. Контрольные вопросы (краткие ответы)

### 1. Чем отличается фиксированный и переменный шаги игрового цикла?

Фиксированный шаг использует постоянный интервал обновления, что удобно для физики и повторяемости.
Переменный шаг использует фактическое `deltaTime` между кадрами, что проще для базовой реализации, но требует ограничения слишком больших значений времени.

### 2. Зачем необходим `RenderAdapter` и можно ли обходиться без него?

`RenderAdapter` уменьшает связанность между игровой логикой и конкретным графическим API.
Без него можно обойтись в маленьком проекте, но код станет хуже расширяться и переноситься на другую библиотеку.

### 3. Какова роль `deltaTime` в управлении физическими процессами и анимациями?

`deltaTime` позволяет изменять параметры объектов пропорционально времени, а не количеству кадров, что делает движение более стабильным при разном FPS.

### 4. Какие преимущества дает использование системы состояний в играх?

Система состояний разделяет поведение приложения по режимам (загрузка, меню, игра), упрощает структуру кода и облегчает добавление новых экранов/режимов.

### 5. Как технически организовать смену графического API («горячую загрузку»)?

Необходимо работать через абстракцию (`IRenderAdapter`) и отделять игровые данные от графических ресурсов.
При смене API создается новый адаптер и выполняется повторная инициализация графических ресурсов, при этом логика игры продолжает работать через общий интерфейс.

---

### Примечание по сдаче

Для финальной версии отчета рекомендуется:

1. Вставить реальные скриншоты в раздел 9.
2. При необходимости перенести текст в шаблон вуза.
3. Экспортировать в PDF и приложить ссылку на репозиторий.
