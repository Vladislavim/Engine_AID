# Архитектура решения

## Общая идея

Проект построен как минимальный каркас игрового движка с разделением ответственности:
- `Application` управляет жизненным циклом программы и главным циклом;
- состояния игры отвечают за поведение в конкретном режиме;
- рендерер скрыт за интерфейсом адаптера;
- ввод вынесен в отдельный класс;
- логирование вынесено в отдельный модуль.

Такое разделение позволяет менять графическую библиотеку и расширять логику без переписывания всего приложения.

## Основные модули

### `Application`

Файлы:
- `src/core/Application.h`
- `src/core/Application.cpp`

Функции:
- инициализация логгера и рендера;
- запуск основного цикла;
- расчет `deltaTime`;
- вызов обновления/отрисовки текущего состояния;
- переключение между состояниями;
- завершение работы и освобождение ресурсов.

`deltaTime` вычисляется через `std::chrono::steady_clock`.
Значение периодически пишется в лог.

### Система состояний

Файлы:
- `src/core/GameState.h`
- `src/core/States.h`
- `src/core/States.cpp`

Реализованы состояния:
- `LoadingState`
- `MenuState`
- `GameplayState`

Каждое состояние имеет единый интерфейс:
- `onEnter()`
- `onExit()`
- `update(...)`
- `render(...)`

Смена состояний выполняется в `Application`.

### RenderAdapter

Файлы:
- `src/render/IRenderAdapter.h`
- `src/render/RaylibRenderAdapter.h`
- `src/render/RaylibRenderAdapter.cpp`

`IRenderAdapter` задает общий интерфейс для работы с окном, вводом и отрисовкой.
Конкретная реализация `RaylibRenderAdapter` использует библиотеку `raylib`.

Преимущество:
- основной код не зависит от конкретного графического API;
- можно заменить `raylib` на другую реализацию адаптера.

### Логирование

Файлы:
- `src/core/Logger.h`
- `src/core/Logger.cpp`

Логгер пишет сообщения:
- в консоль;
- в файл `logs/app.log` (в каталоге сборки).

Логируются:
- запуск и завершение приложения;
- вход/выход из состояний;
- значения `deltaTime`.

### Ввод и управление примитивом

Файлы:
- `src/game/InputController.h`
- `src/game/InputController.cpp`

`InputController` обрабатывает:
- перемещение по стрелкам;
- изменение масштаба по ЛКМ;
- вращение по ПКМ.

Изменения применяются плавно с учетом `deltaTime`.

## Игровой цикл

В каждой итерации выполняется:
1. расчет `deltaTime`;
2. чтение ввода;
3. обновление текущего состояния;
4. отрисовка кадра через адаптер.

Это соответствует базовой схеме игрового цикла из задания.

## Почему выбран `raylib`

Для учебной работы важнее показать архитектуру (`Application`, состояния, адаптер, `deltaTime`), чем низкоуровневую настройку OpenGL.
`raylib` позволяет быстро получить рабочее окно и сосредоточиться на структуре проекта.
